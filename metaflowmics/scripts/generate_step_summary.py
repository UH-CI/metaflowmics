import pandas as pd
from glob import glob

from counter import SequenceCounter

def write_summary(steps,prelim_counts,clustering_thresholds):
    
    # Get list of sample names
    prelim_count_df = pd.DataFrame(prelim_counts).fillna(-1).astype(int).astype(str).replace('-1','/')
    sample_names = prelim_count_df.index

    # Retrieve summaries generated by R
    denoising_step = (pd.read_csv("count_summary.tsv", sep='\t', dtype={'Sample':str})
                      .set_index('Sample')
                      .reindex(sample_names)
                      .fillna('/'))

    # Fill the first counts
    res_all_samples = { id_threshold: [prelim_count_df,denoising_step]
                        for id_threshold in clustering_thresholds }

    # Loop over the remaining steps
    for name, pattern in steps:
        print("Processing {} ({})".format(name,pattern))
        if pattern == -1:
            # Already calculated
            continue

        allow_missing = any(x in name.lower() for x in ['subsampling', 'lulu'])
        if (pattern is None) or (allow_missing and len(glob(pattern))==0):
            # Step doesnt loose any reads/sample (special case when subsampling is deactivated)
            summary_i = [ pd.Series("N/A", index=sample_names, name=name) ]
        elif type(pattern) is str:
            if "*" in pattern:
                # Step with multiple identity thresholds
                summary_i = [ SequenceCounter(name,pattern.replace("*", str(id_threshold)))
                              .run()
                              for id_threshold in clustering_thresholds ]
            else:
                summary_i = [ SequenceCounter(name, pattern).run() ]
        if len(summary_i) == 1:
            summary_i *= len(clustering_thresholds)

        for id_threshold, summary_i_thresh in zip(clustering_thresholds, summary_i):
            res_all_samples[id_threshold].append(summary_i_thresh)

    for id_threshold in clustering_thresholds:
        print("Merging for {}".format(id_threshold))
        summary = pd.concat(res_all_samples[id_threshold],axis=1,sort=True)

        columns_order = sorted(summary.columns, key=lambda x: float(x.split('-')[0]))

        summary = summary.reindex(columns=columns_order)

        # Fill steps that don't filter the data with the previous step count
        for i,col in enumerate(summary.columns):
            if summary[col][0] =='N/A':
                summary[col] = summary[summary.columns[i-1]]

        # If a sample is not in a step, it was discarded -> fill with 0
        summary = summary.fillna('/')
        summary.to_csv("sequences_per_sample_per_step_{}.tsv".format(id_threshold), sep="\t")
